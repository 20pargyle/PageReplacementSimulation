  Assign5 {
  // for loop... 1000 times
    // for (int numFrames=0; numFrames < 100; numFrames++) {
      // pageReferences[] = createPageRefSequence(numFrames);
         // each index is the timestamp or time it will be run; value = page address to be accessed.
      // add new TaskFIFO(pageReferences, numFrames) to thread pool
      // add new TaskLRU(pageReferences) to thread pool
      // add new TaskMRU(pageReferences) to thread pool
    //}
// important for the above: we need some arrays for the page fault counts for each run


  // begin timing
  // run simulations
  // end timing

  // look through result arrays: is pageFaults[i-1] > pageFaults[i] ?
    // if so, report it

}

TaskFIFO implements Runnable{
  private int numPageFaults;

  public TaskFIFO(pageRefArray){
    // queue of length 250 (vm pages)
    	// each item is a spot of virutal memory, occupied by timestamp when it first occupied the current frame
      // replace the page at the head of the queue
      // insert new (or returning) pages at the tail of the queue
    // array of length 1 to 100 (memory frame list)
        // index is a frame (piece of physical memory)
	// each value is a virtual memory address ("refers" to a page number)
  }

  // runs the 1000 page reference sequence
  run(){
    for each pageRef of pageReferences{
      search frameList for pageRef
      if it's not there AKA page fault {
        numPageFaults++;
        is there a free space in frameList (aka is there a negative value) {
          then occupy it
        }
        else {
          queue.pop()
          queue.append(pageRef)?
        }
      }
    }
  }

}

TaskLRU implements Runnable{
  private int numPageFaults;

  public TaskLRU(pageRefArray){
    // array of length 250 (vm pages)
    	// each index is a spot of virutal memory, occupied by timestamp last used
    // hashSet (or array) of length 100 (memory frame list)
        // index is a frame (piece of physical memory)
	// each value is a virtual memory address ("refers" to a page number)
  }

  //runs the entire 1000 page references
  run() {
    for each (pageRef){
      search frameList for pageRef
      if it's not there AKA page fault {
        find lowest timestamp out of pages that stored in the frameList
        toBeRemoved = ^^
	frameList[toBeRemoved] = newPageRef
        numPageFaults++;
      }
    }
  }

}

TaskMRU implements Runnable{
  private int numPageFaults;

  public TaskMRU(pageRefArray){
    // array of length 250 (vm pages)
    	// each index is a spot of virutal memory, occupied by timestamp last used
    // hashSet (or array) of length 100 (memory frame list)
        // index is a frame (piece of physical memory)
	// each value is a virtual memory address ("refers" to a page number)
  }

  //runs the entire 1000 page references
  run(){
    for each (pageRef) {
      search frameList for pageRef
      if it's not there AKA page fault {
        search for highest timestamp of all pages stored in the frameList
        toBeRemoved = ^^
	frameList[toBeRemoved] = newPageRef
        numPageFaults++;
      }
    }
  }

}


TO SOLVE:
 - min page faults reporting
   - semaphore to compare once 3 tasks are done?
   - the arrays can be indexes of a larger global array
 - Belady's Anomaly reporting
   - from existing arrays?

  page fault global list:
    index 0 - TaskFIFO page faults
    index 1 - TaskLRU page faults
    index 2 - TaskMRU page faults